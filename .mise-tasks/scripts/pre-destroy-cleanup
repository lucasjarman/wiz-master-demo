#!/usr/bin/env bash
#
# Pre-destroy cleanup for AWS Load Balancer Controller resources
#
# Strategy (based on ensemble analysis from Claude + Codex):
# 1. Delete LoadBalancer services via kubectl (lets controller clean up properly)
# 2. Wait for controller to delete NLBs and security groups
# 3. Verify cleanup before proceeding
# 4. Force-delete any orphaned resources as fallback
#
# Usage: pre-destroy-cleanup <vpc_id> <region> [--dry-run]
#

set -eo pipefail

VPC_ID="${1:-}"
REGION="${2:-${AWS_DEFAULT_REGION:-${AWS_REGION:-ap-southeast-2}}}"
DRY_RUN="${3:-}"

if [[ -z "$VPC_ID" ]]; then
  echo "Usage: pre-destroy-cleanup <vpc_id> <region> [--dry-run]"
  echo "  VPC_ID is required to scope cleanup to specific VPC"
  exit 1
fi

echo ""
echo "=============================================="
echo "  Pre-Destroy Cleanup for VPC: $VPC_ID"
echo "=============================================="
echo ""

# -----------------------------------------------------------------------------
# Step 1: Delete LoadBalancer Services (let controller clean up properly)
# -----------------------------------------------------------------------------
echo "ðŸŒ Deleting LoadBalancer services (triggers controller cleanup)..."

if command -v kubectl &>/dev/null && kubectl cluster-info &>/dev/null 2>&1; then
  if [[ "$DRY_RUN" != "--dry-run" ]]; then
    # Delete all LoadBalancer type services - this triggers the AWS LB Controller
    # to properly clean up NLBs, target groups, and security groups
    kubectl delete svc -A --field-selector spec.type=LoadBalancer --timeout=120s 2>/dev/null || true
    echo "  âœ… LoadBalancer services deleted"

    # Give the controller time to process deletions
    echo "  â³ Waiting 30s for AWS LB Controller to clean up resources..."
    sleep 30
  else
    echo "  [DRY RUN] Would delete all LoadBalancer services"
  fi
else
  echo "  âš ï¸  kubectl not available or cluster unreachable"
  echo "  (Will proceed with direct AWS resource cleanup)"
fi

# -----------------------------------------------------------------------------
# Step 2: Wait for k8s-* Security Groups to be cleaned up
# -----------------------------------------------------------------------------
echo ""
echo "ðŸ” Verifying k8s-* security groups are cleaned up..."

if [[ "$DRY_RUN" != "--dry-run" ]]; then
  WAIT_TIME=0
  MAX_WAIT=120 # 2 minutes max

  while [[ $WAIT_TIME -lt $MAX_WAIT ]]; do
    SG_COUNT=$(aws ec2 describe-security-groups --region "$REGION" \
      --filters "Name=vpc-id,Values=${VPC_ID}" \
      --query "length(SecurityGroups[?starts_with(GroupName, 'k8s-')])" \
      --output text 2>/dev/null || echo "0")

    if [[ "$SG_COUNT" == "0" ]]; then
      echo "  âœ… All k8s-* security groups cleaned up by controller"
      break
    fi

    echo "  â³ Waiting for k8s-* security groups ($SG_COUNT remaining)..."
    sleep 10
    WAIT_TIME=$((WAIT_TIME + 10))
  done

  if [[ $WAIT_TIME -ge $MAX_WAIT ]]; then
    echo "  âš ï¸  Timeout waiting for controller cleanup - will force-delete"
  fi
fi

# -----------------------------------------------------------------------------
# Step 3: Force-delete app namespaces (prevent Terminating hang)
# -----------------------------------------------------------------------------
echo ""
echo "ðŸ“¦ Force-deleting app namespaces..."

if command -v kubectl &>/dev/null && kubectl cluster-info &>/dev/null 2>&1; then
  # Target namespaces that commonly get stuck: argocd, wiz, react2shell-*
  APP_NAMESPACES=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | tr ' ' '\n' | grep -E '^(argocd|wiz|react2shell-)' || echo "")

  if [[ -n "$APP_NAMESPACES" ]]; then
    for NS in $APP_NAMESPACES; do
      echo "  Force-deleting namespace: $NS"
      if [[ "$DRY_RUN" != "--dry-run" ]]; then
        # Step 1: Remove finalizers using the /finalize API (this is the key fix)
        kubectl get namespace "$NS" -o json 2>/dev/null |
          jq '.spec.finalizers = []' |
          kubectl replace --raw "/api/v1/namespaces/$NS/finalize" -f - 2>/dev/null || true

        # Step 2: Force delete the namespace
        kubectl delete namespace "$NS" --force --grace-period=0 --timeout=30s 2>/dev/null || true
      else
        echo "  [DRY RUN] Would force-delete: $NS"
      fi
    done
    echo "  âœ… App namespaces force-deleted"
  else
    echo "  âœ… No app namespaces found"
  fi
else
  echo "  âš ï¸  kubectl not available or cluster unreachable - skipping namespace cleanup"
  echo "  (This is expected if cluster is already destroyed)"
fi

# -----------------------------------------------------------------------------
# Step 4: Force-delete Load Balancers in VPC (fallback)
# -----------------------------------------------------------------------------
echo ""
echo "ðŸ”„ Force-deleting any remaining Load Balancers in VPC..."

LB_ARNS=$(aws elbv2 describe-load-balancers --region "$REGION" \
  --query "LoadBalancers[?VpcId=='${VPC_ID}'].LoadBalancerArn" --output text 2>/dev/null || echo "")

if [[ -z "$LB_ARNS" || "$LB_ARNS" == "None" ]]; then
  echo "  âœ… No load balancers found in VPC"
else
  for LB_ARN in $LB_ARNS; do
    LB_NAME=$(aws elbv2 describe-load-balancers --region "$REGION" \
      --load-balancer-arns "$LB_ARN" \
      --query 'LoadBalancers[0].LoadBalancerName' --output text 2>/dev/null || echo "unknown")

    echo "  Deleting load balancer: $LB_NAME"
    if [[ "$DRY_RUN" != "--dry-run" ]]; then
      # Delete listeners first
      LISTENER_ARNS=$(aws elbv2 describe-listeners --region "$REGION" \
        --load-balancer-arn "$LB_ARN" \
        --query 'Listeners[*].ListenerArn' --output text 2>/dev/null || echo "")
      for LISTENER_ARN in $LISTENER_ARNS; do
        aws elbv2 delete-listener --region "$REGION" --listener-arn "$LISTENER_ARN" 2>/dev/null || true
      done

      aws elbv2 delete-load-balancer --region "$REGION" --load-balancer-arn "$LB_ARN" 2>/dev/null || true
      echo "    âœ… Deleted: $LB_NAME"
    else
      echo "    [DRY RUN] Would delete: $LB_NAME ($LB_ARN)"
    fi
  done

  # Wait for load balancers to be fully deleted
  if [[ "$DRY_RUN" != "--dry-run" ]]; then
    echo "  â³ Waiting for load balancers to be fully deleted (max 60s)..."
    WAIT_TIME=0
    while [[ $WAIT_TIME -lt 60 ]]; do
      REMAINING=$(aws elbv2 describe-load-balancers --region "$REGION" \
        --query "LoadBalancers[?VpcId=='${VPC_ID}'].LoadBalancerArn" --output text 2>/dev/null || echo "")
      if [[ -z "$REMAINING" || "$REMAINING" == "None" ]]; then
        echo "  âœ… All load balancers deleted"
        break
      fi
      sleep 5
      WAIT_TIME=$((WAIT_TIME + 5))
    done
  fi
fi

# -----------------------------------------------------------------------------
# Step 5: Force-delete Target Groups in VPC (fallback)
# -----------------------------------------------------------------------------
echo ""
echo "ðŸŽ¯ Force-deleting any remaining Target Groups..."

TG_ARNS=$(aws elbv2 describe-target-groups --region "$REGION" \
  --query "TargetGroups[?VpcId=='${VPC_ID}'].TargetGroupArn" --output text 2>/dev/null || echo "")

if [[ -z "$TG_ARNS" || "$TG_ARNS" == "None" ]]; then
  echo "  âœ… No target groups found in VPC"
else
  for TG_ARN in $TG_ARNS; do
    TG_NAME=$(aws elbv2 describe-target-groups --region "$REGION" \
      --target-group-arns "$TG_ARN" \
      --query 'TargetGroups[0].TargetGroupName' --output text 2>/dev/null || echo "unknown")

    echo "  Deleting target group: $TG_NAME"
    if [[ "$DRY_RUN" != "--dry-run" ]]; then
      aws elbv2 delete-target-group --region "$REGION" --target-group-arn "$TG_ARN" 2>/dev/null || true
      echo "    âœ… Deleted: $TG_NAME"
    else
      echo "    [DRY RUN] Would delete: $TG_NAME"
    fi
  done
fi

# -----------------------------------------------------------------------------
# Step 6: Force-delete k8s-* Security Groups in VPC (fallback)
# -----------------------------------------------------------------------------
echo ""
echo "ðŸ”’ Force-deleting any remaining k8s-* security groups..."

SG_IDS=$(aws ec2 describe-security-groups --region "$REGION" \
  --filters "Name=vpc-id,Values=${VPC_ID}" \
  --query "SecurityGroups[?starts_with(GroupName, 'k8s-')].GroupId" \
  --output text 2>/dev/null || echo "")

if [[ -z "$SG_IDS" || "$SG_IDS" == "None" ]]; then
  echo "  âœ… No k8s-* security groups found in VPC"
else
  # First, remove all ingress/egress rules that reference these SGs
  for SG_ID in $SG_IDS; do
    SG_NAME=$(aws ec2 describe-security-groups --region "$REGION" \
      --group-ids "$SG_ID" \
      --query 'SecurityGroups[0].GroupName' --output text 2>/dev/null || echo "unknown")

    echo "  Processing security group: $SG_NAME ($SG_ID)"

    if [[ "$DRY_RUN" != "--dry-run" ]]; then
      # Revoke all ingress rules
      INGRESS_RULES=$(aws ec2 describe-security-groups --region "$REGION" \
        --group-ids "$SG_ID" \
        --query 'SecurityGroups[0].IpPermissions' --output json 2>/dev/null || echo "[]")
      if [[ "$INGRESS_RULES" != "[]" && "$INGRESS_RULES" != "null" ]]; then
        aws ec2 revoke-security-group-ingress --region "$REGION" \
          --group-id "$SG_ID" --ip-permissions "$INGRESS_RULES" 2>/dev/null || true
      fi

      # Revoke all egress rules
      EGRESS_RULES=$(aws ec2 describe-security-groups --region "$REGION" \
        --group-ids "$SG_ID" \
        --query 'SecurityGroups[0].IpPermissionsEgress' --output json 2>/dev/null || echo "[]")
      if [[ "$EGRESS_RULES" != "[]" && "$EGRESS_RULES" != "null" ]]; then
        aws ec2 revoke-security-group-egress --region "$REGION" \
          --group-id "$SG_ID" --ip-permissions "$EGRESS_RULES" 2>/dev/null || true
      fi
    fi
  done

  # Now delete the security groups
  for SG_ID in $SG_IDS; do
    SG_NAME=$(aws ec2 describe-security-groups --region "$REGION" \
      --group-ids "$SG_ID" \
      --query 'SecurityGroups[0].GroupName' --output text 2>/dev/null || echo "unknown")

    echo "  Deleting security group: $SG_NAME ($SG_ID)"
    if [[ "$DRY_RUN" != "--dry-run" ]]; then
      aws ec2 delete-security-group --region "$REGION" --group-id "$SG_ID" 2>/dev/null || true
      echo "    âœ… Deleted: $SG_NAME"
    else
      echo "    [DRY RUN] Would delete: $SG_NAME ($SG_ID)"
    fi
  done
fi

echo ""
echo "=============================================="
echo "  Pre-Destroy Cleanup Complete"
echo "=============================================="
echo ""
